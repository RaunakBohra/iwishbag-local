import { supabase } from '@/integrations/supabase/client';

interface QuoteSubmissionData {
  destination_country: string;
  origin_country: string;
  status: string;
  currency: string;
  user_id: string | null;
  items: any[];
  customer_data: any;
  costprice_total_quote_origincurrency: number;
  final_total_origincurrency: number;
  // V2 specific fields
  validity_days?: number;
  customer_message?: string;
  payment_terms?: string;
  customer_name?: string;
  customer_email?: string;
  customer_phone?: string;
}

export class QuoteV2MigrationService {
  /**
   * Creates a quote in quotes_v2 table with all new fields
   */
  static async createQuoteV2(data: QuoteSubmissionData) {
    try {
      // Extract customer info from customer_data
      const customerEmail = data.customer_data?.info?.email || data.customer_email;
      const customerName = data.customer_name || customerEmail?.split('@')[0] || 'Customer';
      const customerPhone = data.customer_phone || data.customer_data?.info?.phone || null;

      // Prepare items with proper field names for quotes_v2
      const itemsV2 = data.items.map(item => ({
        id: item.id || crypto.randomUUID(),
        name: item.name,
        url: item.url,
        image_url: item.image || item.image_url,
        notes: item.options || item.notes,
        quantity: item.quantity || 1,
        costprice_origin: item.costprice_origin || 0,
        weight: item.weight_kg || item.weight || 0,
        hsn_code: item.hsn_code,
        category: item.category,
        seller: item.seller,
        sku: item.sku,
        customer_notes: item.customer_notes
      }));

      // Create the quote with all V2 fields
      const { data: quote, error } = await supabase
        .from('quotes_v2')
        .insert({
          // Core fields
          destination_country: data.destination_country,
          origin_country: data.origin_country,
          status: data.status,
          // currency is stored in customer_currency column as char(3)
          created_by: data.user_id,
          customer_id: data.user_id,
          items: itemsV2,
          
          // Customer information
          customer_name: customerName,
          customer_email: customerEmail,
          customer_phone: customerPhone,
          
          // Store address and preferences in calculation_data or customer_notes
          // quotes_v2 doesn't have separate address columns
          
          // Pricing - quotes_v2 uses different column names
          total_quote_origincurrency: data.final_total_origincurrency || data.costprice_total_quote_origincurrency,
          total_customer_display_currency: data.final_total_origincurrency || data.costprice_total_quote_origincurrency,
          customer_currency: data.currency || 'USD',
          
          // V2 specific fields
          validity_days: data.validity_days || 7,
          customer_message: data.customer_message || 'Thank you for your quote request. We will review and respond shortly.',
          payment_terms: data.payment_terms || 'Standard payment terms apply',
          
          // Store session ID in calculation_data if needed
          calculation_data: {
            session_id: data.customer_data?.sessionId || null,
            shipping_address: data.customer_data?.shipping_address || null,
            preferences: data.customer_data?.preferences || {}
          },
          
          // Metadata
          source: 'customer_form',
          api_version: 'v2',
          
          // Share token will be auto-generated by trigger
          // Expiry will be auto-calculated by trigger
        })
        .select('*, share_token')
        .single();

      if (error) {
        console.error('Error creating quote v2:', error);
        throw error;
      }

      return { quote, error: null };
    } catch (error) {
      console.error('QuoteV2MigrationService error:', error);
      return { quote: null, error };
    }
  }

  /**
   * Checks if quotes_v2 features are enabled
   */
  static async isV2Enabled(): Promise<boolean> {
    try {
      // Check if quotes_v2 table is accessible
      const { error } = await supabase
        .from('quotes_v2')
        .select('id')
        .limit(1);
      
      return !error;
    } catch {
      return false;
    }
  }

  /**
   * Migrates an existing quote from quotes to quotes_v2
   */
  static async migrateQuoteToV2(quoteId: string) {
    try {
      // Fetch the original quote
      const { data: originalQuote, error: fetchError } = await supabase
        .from('quotes_v2')
        .select('*')
        .eq('id', quoteId)
        .single();

      if (fetchError || !originalQuote) {
        throw new Error('Quote not found');
      }

      // Create V2 quote data
      const v2Data: QuoteSubmissionData = {
        destination_country: originalQuote.destination_country,
        origin_country: originalQuote.origin_country,
        status: originalQuote.status,
        currency: originalQuote.currency,
        user_id: originalQuote.user_id,
        items: originalQuote.items || [],
        customer_data: originalQuote.customer_data || {},
        costprice_total_quote_origincurrency: originalQuote.costprice_total_quote_origincurrency || 0,
        final_total_origincurrency: originalQuote.final_total_origincurrency || 0,
        customer_email: originalQuote.email,
        customer_name: originalQuote.customer_name,
        customer_phone: originalQuote.phone
      };

      // Create the V2 quote
      const { quote: v2Quote, error: createError } = await this.createQuoteV2(v2Data);

      if (createError || !v2Quote) {
        throw createError || new Error('Failed to create V2 quote');
      }

      // Update the original quote with reference to V2
      await supabase
        .from('quotes_v2')
        .update({ 
          external_reference: v2Quote.id,
          updated_at: new Date().toISOString()
        })
        .eq('id', quoteId);

      return { v2Quote, error: null };
    } catch (error) {
      console.error('Migration error:', error);
      return { v2Quote: null, error };
    }
  }
}